/*******************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.3.6.
 *
 * You need to add your implementation here to:
 *    - get telemetry data from device/sensor
 *    - set read-only property data
 *    - handle read-write property callback
 *    - process device command
 *
 * Generated Date: Wednesday, July 24, 2019
 *******************************************************************************************/

#include "IoT_DevKit_HW.h"
#include "sample_device_impl.h"
#include "utilities/digitaltwin_serializer.h"
#include "utilities/deviceinfo_interface.h"
#include "utilities/sensor_interface.h"

#define Payload_Buffer_Size 256

double Sensor_Telemetry_ReadTemp()
{
    return getDevKitTemperatureValue(0);
}

double Sensor_Telemetry_ReadHumid()
{
    return getDevKitHumidityValue();
}

void SendTelemetry_Succeeded_Callback(const char* interfaceName, const char* telemetryName)
{
    // If needed, put your business logic here to handle the confirmation of the delivery for device telemetry on success.

    LogInfo("DigitalTwin successfully delivered telemetry message for %s::%s", interfaceName, telemetryName);
}

void SendTelemetry_Error_Callback(const char* interfaceName, const char* telemetryName)
{
    // If needed, put your business logic here to handle the confirmation of the delivery for device telemetry on failure.

    LogInfo("DigitalTwin failed to deliver telemetry message for %s::%s", interfaceName, telemetryName);
}

void ReportProperty_Succeeded_Callback(const char* interfaceName, const char* propertyName)
{
    // If needed, put your business logic here to handle the result callback reporting property on success.

    LogInfo("DigitalTwin successfully report writable property for %s::%s", interfaceName, propertyName);
}

void ReportProperty_Error_Callback(const char* interfaceName, const char* propertyName)
{
    // If needed, put your business logic here to handle the result callback of reporting property on failure.

    LogInfo("DigitalTwin failed to report writable property for %s::%s", interfaceName, propertyName);
}

char* Deviceinfo_Property_GetManufacturer()
{
    return "MXChip";
}

char* Deviceinfo_Property_GetModel()
{
    return "AZ3166";
}

char* Deviceinfo_Property_GetSwVersion()
{
    return "1.0.0";
}

char* Deviceinfo_Property_GetOsName()
{
    return "mbedOS5";
}

char* Deviceinfo_Property_GetProcessorArchitecture()
{
    return "ARM cortex M4";
}

char* Deviceinfo_Property_GetProcessorManufacturer()
{
    return "STMicro";
}

long Deviceinfo_Property_GetTotalStorage()
{
    return 2097152L;
}

long Deviceinfo_Property_GetTotalMemory()
{
    return 262144L;
}

bool Sensor_Property_GetState()
{
    return getButtonBState();
}

bool Sensor_Property_NameCallback(char* name)
{
    LogInfo("Name property new value: %s", name);
    char text[20];
    sprintf(text, "CX: %s", name);
    textOutDevKitScreen(3, text, 0);
    return true;
}

bool Sensor_Property_BrightnessCallback(long brightness)
{
    LogInfo("Brightness property new value: %ld", brightness);
    turnOnRGBLED(brightness, brightness, brightness);
    return true;
}

DIGITALTWIN_COMMAND_RESULT Sensor_Command_Blink(long interval, SENSOR_BLINK_blinkResponse* response, unsigned int* statusCode)
{
    LogInfo("Parameter interval: %ld", interval);

    if (interval > 0 && interval <= 60)
    {
        startBlinkDevKitRGBLED(interval * 1000);
        response->description = "Start blinking";
    }
    else
    {
        response->description = "Invalid interval";
    }
    
    *statusCode = 200;
    LogInfo("Device executed 'blink' command successfully");
    return DIGITALTWIN_COMMAND_OK;

}

DIGITALTWIN_COMMAND_RESULT Sensor_Command_Turnon(unsigned int* statusCode)
{
    turnOnUserLED();
    *statusCode = 200;
    LogInfo("Execute 'turnon' command successfully");
    return DIGITALTWIN_COMMAND_OK;

}

DIGITALTWIN_COMMAND_RESULT Sensor_Command_Turnoff(unsigned int* statusCode)
{
    turnOffUserLED();
    *statusCode = 200;
    LogInfo("Execute 'turnoff' command successfully");
    return DIGITALTWIN_COMMAND_OK;

}

DIGITALTWIN_COMMAND_RESULT Sensor_Command_Rundiagnostics()
{
    char responseString[Payload_Buffer_Size] = "Run rundiagnostics command successfully";
    textOutDevKitScreen(3, "Calibrating...", 0);
    SensorInterface_Rundiagnostics_UpdateStatus(SENSOR_RUNDIAGNOSTICS_COMPLETED, (const char*)responseString, 200);
    textOutDevKitScreen(3, "Calibrated!", 0);
    LogInfo("Execute 'rundiagnostics' command successfully");
    return DIGITALTWIN_COMMAND_OK;
}

